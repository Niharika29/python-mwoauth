"""
Provides a collection of utilities for easily working with MediaWiki's OAuth1.0a
implementation.

Example:

.. code-block::python

	import mwoauth, six
	from six.moves import input # For compatibility between python 2 and 3
	
	# Construct handshaker
	handshaker = mwoauth.Handshaker("https://en.wikipedia.org/w/index.php", 
									mwoauth.Consumer("<key>", "<secret>"))
	
	# Step 1: Initialize
	redirect, resource_owner = handshaker.initiate()
	
	# Step 2: Authorize
	print("Point your browser to: %s" % redirect) # 
	response_qs = input("Response query string: ")
	
	# Step 3: Complete
	authorized_resource_owner = handshaker.complete(resource_owner, response_qs)
	
	# Step 4: Identify (optional)
	print(handshaker.identify(authorized_resource_owner))

"""
from collections import namedtuple
import jwt, requests, time, six
from requests_oauthlib import OAuth1
import six
try:
	from urlparse import parse_qs
except ImportError:
	from urllib.parse import parse_qs

try:
	from urllib import urlencode
except ImportError:
	from urllib.parse import urlencode

try:
	from urlparse import urlparse
except ImportError:
	from urllib.parse import urlparse



ResourceOwner = namedtuple("ResourceOwner", ['key', 'secret'])
"""
Represents a key/secret pair for a user (AKA "resource owner").  Note that both
temporary and authorized key/secret pairs can be stored.

:Parameters:
	key : `str`
		A hex string identifying the user
	secret : `str`
		A hex string used to sign requests as **from** a particular 
		user/resource owner
"""

Consumer = namedtuple("Consumer", ['key', 'secret'])
"""
Represents a key/secret pair for a consumer/client (your system).  These keys 
and secrets are provided by MediaWiki when registering an OAuth consumer.  
See "Special:OAuthConsumerRegistration" on wikis with Extension:OAuth installed.

:Parameters:
	key : `str`
		A hex string identifying the consumer/client with a MediaWiki instance.
	secret : `str`
		A hex string used to encrypt/decrypt communications with a MediaWiki
		instance.
"""

def safe_parse_qs(qs):
	params = parse_qs(qs)
	safe_params = {}
	for key in params:
		values = params[key]
		safe_params[six.b(key)] = [six.b(v) for v in values]
	
	return safe_params

def initiate(uri, consumer):
	"""
	Initiates an oauth handshake with MediaWiki and returns a URL to
	redirect the user to and a `ResourceOwner` to validate responses
	against.
	
	:Parameters:
		uri : `str`
			The base URI of the wiki to authenticate with.  Should end in
			"/w/index.php". 
		consumer : `Consumer`
			A key/secret pair representing the consumer/client
	
	:Returns:
		A pair of values representing the URL to redirect the user to and 
		a `ResourceOwner` containing a temporary key/secret pair for the 
		user.  Note that this key/secret pair is not useful beyond this
		step of the handshake.  `complete()` must be called to obtain an 
		authorized key/secret pair.
		
		redirect_url : `str`
			A URL to send the user ("resource owner")
		resource_owner : `ResourceOwner`
			An object containing resource owner information 
			(pass this to `complete()`)
		
	
	"""
	auth = OAuth1(consumer.key,
				  client_secret=consumer.secret,
				  callback_uri='oob')
	
	r = requests.post(url=uri,
					  params={'title': "Special:OAuth/initiate"},
					  auth=auth)
	
	credentials = parse_qs(r.content)
	
	resource_owner = ResourceOwner(
		credentials.get(six.b('oauth_token'))[0],
		credentials.get(six.b('oauth_token_secret'))[0]
	)
	
	return (
		(
			self.uri + "?" + 
			urlencode({'title': "Special:OAuth/authorize",
					   'oauth_token': resource_owner.key,
					   'oauth_consumer.key': self.consumer.key})
		),
		resource_owner
	)

def complete(uri, consumer, resource_owner, response_qs):
	"""
	Completes an OAuth handshake with MediaWiki.
	
	:Parameters:
		uri : `str`
			The base URI of the wiki to authenticate with.  Should end in
			"/w/index.php". 
		consumer : `Consumer`
			A key/secret pair representing the consumer/client
		resource_owner : ResourceOwner
			A temporary key/secret pair from a call to `initiate()`
		response_qs : `bytes`
			The query string generated by MediaWiki after the user 
			completed the authorization step.  (Everything after "?" in the
			URL.)
		
	:Returns:
		A `ResourceOwner` containing the authorized key/secret pair that 
		can be stored and used as long as the does not deauthorize the consumer.
	"""
	callback_data = safe_parse_qs(response_qs)
	
	# TODO probably not assert
	# Handle lack of oauth_token
	# etc. 
	assert resource_owner.key == callback_data.get(six.b("oauth_token"))[0]
	
	verifier = callback_data.get(six.b("oauth_verifier"))[0]
	
	auth = OAuth1(self.consumer.key, 
				  client_secret=self.consumer.secret,
				  resource_owner_key=resource_owner.key,
				  resource_owner_secret=resource_owner.secret,
				  verifier=verifier)
	
	r = requests.post(url=self.uri,
					  params={'title': "Special:OAuth/token"},
					  auth=auth)
	
	credentials = parse_qs(r.content)
	authorized_owner = ResourceOwner(
		credentials.get(six.b('oauth_token'))[0],
		credentials.get(six.b('oauth_token_secret'))[0]
	)
	
	return authorized_owner

def identify(uri, consumer, resource_owner, leeway=10):
	"""
	Gather's identifying information about an authorized resource_owner.
	
	:Parameters:
		uri : `str`
			The base URI of the wiki to authenticate with.  Should end in
			"/w/index.php". 
		consumer : `Consumer`
			A key/secret pair representing the consumer/client
		resource_owner : `ResourceOwner`
			An **authorized** resource owner obtained from `complete()`
		
	:Returns:
		A dictionary containing identity information.
	"""
	
	# Construct an OAuth auth
	auth = OAuth1(self.consumer.key, 
	              client_secret=self.consumer.secret,
	              resource_owner_key=resource_owner.key,
	              resource_owner_secret=resource_owner.secret)
	
	# Request the identity using auth
	# TODO: What exception do we throw when the resource owner is invalid?
	r = requests.post(url=self.uri,
	                  params={'title': "Special:OAuth/identify"},
	                  auth=auth)
	
	# Decode json & stuff
	try:
		identity, signing_input, header, signature = jwt.load(r.content)
	except jwt.DecodeError as e:
		raise Exception("An error occurred while trying to read json " + \
		                "content: {0}".format(e))
	
	# Ensure no downgrade in authentication
	if not header['alg'] == "HS256":
		raise Exception("Unexpected algorithm used for authentication " + \
		                "{0}, expected {1}".format("HS256", header['alg']))
	
	
	# Check signature
	try:
		jwt.verify_signature(identity, signing_input, header, signature,
		                     self.consumer.secret, False)
	except jwt.DecodeError as e:
		raise Exception("Could not verify the jwt signature: {0}".format(e))
	
	
	# Verify the issuer is who we expect (server sends $wgCanonicalServer)
	issuer = urlparse(identity['iss']).netloc
	expected_domain = urlparse(self.uri).netloc
	if not issuer == expected_domain:
		raise Exception("Unexpected issuer " + \
		                "{0}, expected {1}".format(issuer, expected_domain))
	
	
	# Verify we are the intended audience of this response
	audience = identity['aud']
	if not audience == self.consumer.key:
		raise Exception("Unexpected audience " + \
		                "{0}, expected {1}".format(aud, my_domain))
	
	now = time.time()
	
	# Check that the identity was issued in the past.
	issued_at = identity['iat']
	if not now >= issued_at - leeway:
		raise Exception("Identity issued {0} ".format(issued_at - now) + \
		                "seconds in the future!")
	
	# Check that the identity has not yet expired
	expiration = identity['exp']
	if not now <= expiration:
		raise Exception("Identity expired {0} ".format(expiration - now) + \
		                "seconds ago!")
	
	# Verify we haven't seen this nonce before,
	# which would indicate a replay attack
	# TODO: implement nonce but this is not high priority
	#if identity['nonce'] != <<original request nonce>>
		#raise Exception('JSON Web Token Validation Problem, nonce')
	
	return identity


class Handshaker:
	"""
	Constructs a client for managing an OAuth handshake.
	
	:Parameters:
		uri : `str`
			The base URI of the wiki (provider) to authenticate with.  This uri
			should end in "/w/index.php". 
		consumer : `Consumer`
			consumer/client
	"""
	def __init__(self, uri, consumer):
		self.uri = uri
		self.consumer = consumer
	
	def initiate(self):
		return initiate(self.uri, self.consumer)
		
	def complete(self, resource_owner, response_qs):
		return complete(self.uri, self.consumer, resource_owner, response_qs)
	
	def identify(self, resource_owner):
		return identify(self.uri, self.consumer, resource_owner)
