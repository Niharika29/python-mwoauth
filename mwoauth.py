"""
Provides a collection of utilities for easily working with MediaWiki's OAuth1.0a
implementation.

Example:

.. code-block::python

	import mwoauth
	from six.moves import input # For compatibility between python 2 and 3
	
	# Consruct a "consumer" from the key/secret provided by MediaWiki
	import config
	consumer = mwoauth.Consumer(config.consumer_key, config.consumer_secret)
	
	# Construct handshaker with wiki URI and consumer
	handshaker = mwoauth.Handshaker("https://en.wikipedia.org/w/index.php",
	                                consumer)
	
	# Step 1: Initialize -- ask MediaWiki for a temporary key/secret for user
	redirect, resource_owner = handshaker.initiate()
	
	# Step 2: Authorize -- send user to MediaWiki to confirm authorization
	print("Point your browser to: %s" % redirect) # 
	response_qs = input("Response query string: ")
	
	# Step 3: Complete -- obtain authorized key/secret for "resource owner"
	authorized_resource_owner = handshaker.complete(resource_owner, response_qs)
	
	# Step 4: Identify -- (optional) get identifying information about the user
	identity = handshaker.identify(authorized_resource_owner)
	
	# Print results
	print("Identified as {username}.".format(**identity))
	print("key={0}".format(authorized_resource_owner.key))
	print("secret={0}".format(authorized_resource_owner.secret))

"""
from collections import namedtuple
import jwt, requests, time, six
from requests_oauthlib import OAuth1
import six

try:
	from urlparse import parse_qs
except ImportError:
	from urllib.parse import parse_qs

try:
	from urllib import urlencode
except ImportError:
	from urllib.parse import urlencode

try:
	from urlparse import urlparse
except ImportError:
	from urllib.parse import urlparse



ResourceOwner = namedtuple("ResourceOwner", ['key', 'secret'])
"""
Represents a key/secret pair for a user (AKA "resource owner").  Note that both
temporary and authorized key/secret pairs can be stored.

:Parameters:
	key : `str`
		A hex string identifying the user
	secret : `str`
		A hex string used to sign requests as **from** a particular 
		user/resource owner
"""

Consumer = namedtuple("Consumer", ['key', 'secret'])
"""
Represents a key/secret pair for a consumer/client (your system).  These keys 
and secrets are provided by MediaWiki when registering an OAuth consumer.  
See "Special:OAuthConsumerRegistration" on wikis with Extension:OAuth installed.

:Parameters:
	key : `str`
		A hex string identifying the consumer/client with a MediaWiki instance.
	secret : `str`
		A hex string used to encrypt/decrypt communications with a MediaWiki
		instance.
"""

def safe_parse_qs(qs):
	params = parse_qs(qs)
	
	if params != None:
		safe_params = {}
		for key in params:
			values = params[key]
			safe_params[six.b(key)] = [six.b(v) for v in values]
		
		return safe_params
	

def initiate(uri, consumer):
	"""
	Initiates an oauth handshake with MediaWiki and returns a URL to
	redirect the user to and a `ResourceOwner` to validate responses
	against.
	
	:Parameters:
		uri : `str`
			The base URI of the wiki to authenticate with.  Should end in
			"/w/index.php". 
		consumer : `Consumer`
			A key/secret pair representing the consumer/client
	
	:Returns:
		A pair of values representing the URL to redirect the user to and 
		a `ResourceOwner` containing a temporary key/secret pair for the 
		user.  Note that this key/secret pair is not useful beyond this
		step of the handshake.  `complete()` must be called to obtain an 
		authorized key/secret pair.
		
		redirect_url : `str`
			A URL to send the user ("resource owner")
		resource_owner : `ResourceOwner`
			An object containing resource owner information 
			(pass this to `complete()`)
		
	
	"""
	auth = OAuth1(consumer.key,
				  client_secret=consumer.secret,
				  callback_uri='oob')
	
	r = requests.post(url=uri,
					  params={'title': "Special:OAuth/initiate"},
					  auth=auth)
	
	credentials = parse_qs(r.content)
	
	if credentials == None:
		raise Exception("Expected x-www-form-urlencoded response from " + \
		                "MediaWiki, but got some HTML formatted error instead.")
	
	resource_owner = ResourceOwner(
		credentials.get(six.b('oauth_token'))[0],
		credentials.get(six.b('oauth_token_secret'))[0]
	)
	
	return (
		uri + "?" + urlencode({'title': "Special:OAuth/authorize",
		                       'oauth_token': resource_owner.key,
		                       'oauth_consumer_key': consumer.key}),
		resource_owner
	)

def complete(uri, consumer, resource_owner, response_qs):
	"""
	Completes an OAuth handshake with MediaWiki.
	
	:Parameters:
		uri : `str`
			The base URI of the wiki to authenticate with.  Should end in
			"/w/index.php". 
		consumer : `Consumer`
			A key/secret pair representing the consumer/client
		resource_owner : ResourceOwner
			A temporary key/secret pair from a call to `initiate()`
		response_qs : `bytes`
			The query string generated by MediaWiki after the user 
			completed the authorization step.  (Everything after "?" in the
			URL.)
		
	:Returns:
		A `ResourceOwner` containing the authorized key/secret pair that 
		can be stored and used as long as the does not deauthorize the consumer.
	"""
	callback_data = safe_parse_qs(response_qs)
	
	# Check if the query string references the right temp resource owner key
	callback_owner_key = callback_data.get(six.b("oauth_token"))[0]
	if not resource_owner.key == callback_owner_key:
		raise Exception("Unexpect resource owner key " + \
		                "{0}, expected {1}.".format(callback_owner_key,
		                                            resource_owner.key))
	
	# Get the verifier token
	verifier = callback_data.get(six.b("oauth_verifier"))[0]
	
	# Construct a new auth with the verifier
	auth = OAuth1(consumer.key, 
				  client_secret=consumer.secret,
				  resource_owner_key=resource_owner.key,
				  resource_owner_secret=resource_owner.secret,
				  verifier=verifier)
	
	# Send the verifier and ask for an authorized resource owner key/secret
	r = requests.post(url=uri,
					  params={'title': "Special:OAuth/token"},
					  auth=auth)
	
	# Parse response and construct an authorized resource owner
	credentials = parse_qs(r.content)
	
	if credentials == None:
		raise Exception("Expected x-www-form-urlencoded response from " + \
		                "MediaWiki, but got some HTML formatted error instead.")
	
	authorized_owner = ResourceOwner(
		credentials.get(six.b('oauth_token'))[0],
		credentials.get(six.b('oauth_token_secret'))[0]
	)
	
	return authorized_owner

def identify(uri, consumer, resource_owner, leeway=10):
	"""
	Gather's identifying information about an authorized resource_owner.
	
	:Parameters:
		uri : `str`
			The base URI of the wiki to authenticate with.  Should end in
			"/w/index.php". 
		consumer : `Consumer`
			A key/secret pair representing the consumer/client
		resource_owner : `ResourceOwner`
			An **authorized** resource owner obtained from `complete()`
		
	:Returns:
		A dictionary containing identity information.
	"""
	
	# Construct an OAuth auth
	auth = OAuth1(consumer.key, 
	              client_secret=consumer.secret,
	              resource_owner_key=resource_owner.key,
	              resource_owner_secret=resource_owner.secret)
	
	# Request the identity using auth
	r = requests.post(url=uri,
	                  params={'title': "Special:OAuth/identify"},
	                  auth=auth)
	
	# Decode json & stuff
	try:
		identity, signing_input, header, signature = jwt.load(r.content)
	except jwt.DecodeError as e:
		raise Exception("An error occurred while trying to read json " + \
		                "content: {0}".format(e))
	
	# Ensure no downgrade in authentication
	if not header['alg'] == "HS256":
		raise Exception("Unexpected algorithm used for authentication " + \
		                "{0}, expected {1}".format("HS256", header['alg']))
	
	
	# Check signature
	try:
		jwt.verify_signature(identity, signing_input, header, signature,
		                     consumer.secret, False)
	except jwt.DecodeError as e:
		raise Exception("Could not verify the jwt signature: {0}".format(e))
	
	
	# Verify the issuer is who we expect (server sends $wgCanonicalServer)
	issuer = urlparse(identity['iss']).netloc
	expected_domain = urlparse(uri).netloc
	if not issuer == expected_domain:
		raise Exception("Unexpected issuer " + \
		                "{0}, expected {1}".format(issuer, expected_domain))
	
	
	# Verify we are the intended audience of this response
	audience = identity['aud']
	if not audience == consumer.key:
		raise Exception("Unexpected audience " + \
		                "{0}, expected {1}".format(aud, my_domain))
	
	now = time.time()
	
	# Check that the identity was issued in the past.
	issued_at = float(identity['iat'])
	if not now >= (issued_at - leeway):
		raise Exception("Identity issued {0} ".format(issued_at - now) + \
		                "seconds in the future!")
	
	# Check that the identity has not yet expired
	expiration = float(identity['exp'])
	if not now <= expiration:
		raise Exception("Identity expired {0} ".format(expiration - now) + \
		                "seconds ago!")
	
	# Verify we haven't seen this nonce before,
	# which would indicate a replay attack
	# TODO: implement nonce but this is not high priority
	#if identity['nonce'] != <<original request nonce>>
		#raise Exception('JSON Web Token Validation Problem, nonce')
	
	return identity


class Handshaker:
	"""
	Constructs a client for managing an OAuth handshake.
	
	:Parameters:
		uri : `str`
			The base URI of the wiki (provider) to authenticate with.  This uri
			should end in "/w/index.php". 
		consumer : `Consumer`
			consumer/client
	"""
	def __init__(self, uri, consumer):
		self.uri = uri
		self.consumer = consumer
	
	def initiate(self):
		return initiate(self.uri, self.consumer)
		
	def complete(self, resource_owner, response_qs):
		return complete(self.uri, self.consumer, resource_owner, response_qs)
	
	def identify(self, resource_owner):
		return identify(self.uri, self.consumer, resource_owner)
